/*!
 * v-movable v0.3.2
 * (c) Ron Gilchrist (thewebkid)
 * Released under the MIT License.
 */
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Vue = _interopDefault(require('vue'));
var __vue_normalize__ = _interopDefault(require('vue-runtime-helpers/dist/normalize-component.mjs'));
var __vue_create_injector__ = _interopDefault(require('vue-runtime-helpers/dist/inject-style/browser.mjs'));

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var pxVal = function pxVal(v) {
  return isFinite(v) ? Number(v) : Number(v.replace(/[^0-9.\-]/g, ''));
};

var childOf = function childOf(pid, child) {
  while (child.getAttribute('moveid') !== pid) {
    child = child.parentElement;

    if (!child || child.tagName === 'BODY') {
      return false;
    }
  }

  return true;
};

var getClickOffset = function getClickOffset(event) {
  var coords = {
    x: event.pageX,
    y: event.pageY
  };
  var off = event.target.getBoundingClientRect();
  return {
    x: coords.x - (off.left + document.body.scrollLeft),
    y: coords.y - (off.top + document.body.scrollTop)
  };
};

var guid = function guid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0;
    var v = c === 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}; //endregion


Vue.directive('movable', {
  update: function update(el, binding) {
    if (el.getAttribute('moveid')) {
      return; //don't continuously rebind
    }

    var args = binding.value;

    if (!!args.disabled) {
      return;
    }

    var shiftBehavior = !!args.shiftKey;
    var grid = args.grid || 1;
    var bounds = args.bounds || null;

    var directionalBounds = function directionalBounds(v) {
      return Array.isArray(v) ? v : !isNaN(Number(v)) ? [Math.min(0, Number(v)), Math.max(0, Number(v))] : [-Infinity, Infinity];
    };

    if (args.vertical) {
      bounds = {
        x: [0, 0],
        y: directionalBounds(args.vertical)
      };
    } else if (args.horizontal) {
      bounds = {
        y: [0, 0],
        x: directionalBounds(args.horizontal)
      };
    }

    var actualBounds = {
      left: null,
      top: null
    };
    var target = args.target || el;
    target.style.touchAction = 'none';
    var moveId = guid();
    var targetId = 'target' + moveId;
    target.setAttribute('moveid', targetId);
    el.setAttribute('moveid', moveId);
    var onstart = args.onstart;
    var onmove = args.onmove;
    var oncomplete = args.oncomplete;
    var moveObj = {};
    var isMoving;
    var pointerId;
    var pointerEvents = window.MSPointerEvent ? {
      start: 'MSPointerDown',
      move: 'MSPointerMove',
      end: 'MSPointerUp'
    } : //IE, grr
    window.PointerEvent ? {
      start: 'pointerdown',
      move: 'pointermove',
      end: 'pointerup'
    } : //most everyone
    'ontouchstart' in document.documentElement ? {
      start: 'touchstart',
      move: 'touchmove',
      end: 'touchend'
    } : {
      start: 'mousedown',
      move: 'mousemove',
      end: 'mouseup'
    }; //safari. grr

    var init = function init() {
      setBounds();

      var halt = function halt(etarget) {
        return etarget.getAttribute('move-disabled') || etarget.getAttribute('moveid') === targetId || !childOf(moveId, etarget) || isMoving;
      };

      if (window.PointerEvent || window.MSPointerEvent) {
        document.body.addEventListener(pointerEvents.start, function (event) {
          if (halt(event.target)) {
            return;
          }

          document.body.setPointerCapture(event.pointerId);
          event.preventDefault();
          event.stopPropagation();

          if (event.pointerId !== undefined) {
            pointerId = event.pointerId;
          }

          moveInit(event);
          document.body.addEventListener(pointerEvents.end, unbind, false);
          document.body.addEventListener(pointerEvents.move, function (evt) {
            if (pointerId !== undefined && evt.pointerId === pointerId) {
              motionHandler(evt);
            }
          }, false);
        }, false);
      } else {
        var start = function start(event) {
          if (halt(event.target)) {
            return;
          }

          event.preventDefault();
          event.stopImmediatePropagation();
          moveInit(event);
          document.body.addEventListener(pointerEvents.end, unbind, false);
          document.body.addEventListener(pointerEvents.move, motionHandler, false);
        };

        target.addEventListener(pointerEvents.start, start, false);
      }
    };

    function setBounds(newBounds) {
      bounds = newBounds || bounds;

      if (!bounds) {
        actualBounds.left = [0 - Infinity, Infinity];
        actualBounds.top = [0 - Infinity, Infinity];
        return;
      }

      var css = {
        left: pxVal(target.style.left) || 0,
        top: pxVal(target.style.top) || 0
      };

      if (bounds.x) {
        actualBounds.left = [css.left + bounds.x[0], css.left + bounds.x[1]];
      } else {
        actualBounds.left = [0 - Infinity, Infinity];
      }

      if (bounds.y) {
        actualBounds.top = [css.top + bounds.y[0], css.top + bounds.y[1]];
      } else {
        actualBounds.top = [0 - Infinity, Infinity];
      }
    } //#endregion
    //#region event handlers


    var moveInit = function moveInit(event) {
      moveObj.mouseCoord = getCoord(event);
      moveObj.startCoord = {
        x: pxVal(target.style.left),
        y: pxVal(target.style.top)
      };
      if (isNaN(moveObj.startCoord.x)) moveObj.startCoord.x = 0;
      if (isNaN(moveObj.startCoord.y)) moveObj.startCoord.y = 0;
      moveObj.moveDist = {
        x: 0,
        y: 0
      };
      moveObj.totalDist = {
        x: 0,
        y: 0
      };
      moveObj.clickOffset = getClickOffset(event);
      moveObj.css = {
        top: moveObj.startCoord.y,
        left: moveObj.startCoord.x
      };
      moveObj.maxX = actualBounds.left[0] + actualBounds.left[1];
      moveObj.maxY = actualBounds.top[0] + actualBounds.top[1];
      isMoving = true;
      args.reposition(true);
      args.eventBroker({
        name: 'start',
        args: moveObj
      });

      if (onstart) {
        onstart(moveObj);
      }
    };

    var motionHandler = function motionHandler(evt) {
      evt.stopPropagation();
      var newCoord = getCoord(evt);
      moveObj.moveDist = {
        x: newCoord.x - moveObj.mouseCoord.x,
        y: newCoord.y - moveObj.mouseCoord.y
      };
      moveObj.mouseCoord = newCoord;
      moveObj.totalDist = {
        x: moveObj.totalDist.x + moveObj.moveDist.x,
        y: moveObj.totalDist.y + moveObj.moveDist.y
      };
      moveObj.css.top = moveObj.totalDist.y;
      moveObj.css.left = moveObj.totalDist.x;
      moveObj.gridCss = {
        left: Math.round(moveObj.totalDist.x / grid) * grid + moveObj.startCoord.x,
        top: Math.round(moveObj.totalDist.y / grid) * grid + moveObj.startCoord.y
      };
      moveObj.css = moveObj.gridCss;

      var isInfinite = function isInfinite(bounds) {
        return bounds === undefined || Array.isArray(bounds) && bounds[0] < -99999 && bounds[1] > 99999;
      };

      if (shiftBehavior && evt.shiftKey && (bounds === null || isInfinite(bounds.x) && isInfinite(bounds.y))) {
        var _moveObj$totalDist = moveObj.totalDist,
            x = _moveObj$totalDist.x,
            y = _moveObj$totalDist.y;

        if (Math.abs(x) > Math.abs(y)) {
          moveObj.css.top = moveObj.startCoord.y;
        } else {
          moveObj.css.left = moveObj.startCoord.x;
        }
      } else {
        moveObj.css.top = Math.min(Math.max(actualBounds.top[0], moveObj.css.top), actualBounds.top[1]);
        moveObj.css.left = Math.min(Math.max(actualBounds.left[0], moveObj.css.left), actualBounds.left[1]);
      }

      moveObj.pctX = Math.max(actualBounds.left[0], moveObj.css.left) / moveObj.maxX;
      moveObj.pctY = Math.max(actualBounds.top[0], moveObj.css.top) / moveObj.maxY;
      args.reposition(moveObj.css);

      if (onmove) {
        onmove(moveObj);
      }

      args.eventBroker({
        name: 'move',
        args: moveObj
      });
    };

    var unbind = function unbind(evt) {
      pointerId = null;
      isMoving = false;
      document.body.removeEventListener(pointerEvents.move, motionHandler);
      moveEnd(evt);
    };

    var moveEnd = function moveEnd(event) {
      document.body.removeEventListener(pointerEvents.end, unbind);
      if (oncomplete) oncomplete(moveObj);
      isMoving = moveObj.isMoving = false;
      args.reposition(false);
      args.eventBroker({
        name: 'complete',
        args: moveObj
      });

      if (event) {
        event.preventDefault();
      }
    }; //#endregion


    var getCoord = function getCoord(evt) {
      var coord = {};
      coord.x = evt.pageX;
      coord.y = evt.pageY;
      return coord;
    };

    var rpcCall = function rpcCall(action, arg) {
      console.log({
        rpc: {
          action: action,
          arg: arg
        }
      });
    };

    init();
    args.directiveInit(rpcCall);
  }
});

var script = {
  data: function data() {
    return {
      tag: 'div',
      top: undefined,
      left: undefined,
      moveArgs: {},
      isMoving: false,
      rpcFunc: function rpcFunc() {},
      hasInit: false
    };
  },
  computed: {
    px: function px() {
      return function (v) {
        return "".concat(v, "px");
      };
    },
    position: function position() {
      return this['events-only'] || !this.init ? {} : {
        top: this.px(this.top),
        left: this.px(this.left)
      };
    }
  },
  name: 'movable',
  methods: {
    init: function init() {
      var vm = this;

      if (vm['tagName']) {
        this.tag = this.tagName;
      }

      this.top = this['posTop'] ? Number(this.posTop) : this.$el.offsetTop; //Number(this.position.top.replace('px',''));

      this.left = this['posLeft'] ? Number(this.posLeft) : this.$el.offsetLeft; //Number(this.position.left.replace('px',''));

      vm.hasInit = true;
      var moveArgs = {
        reposition: this.reposition,
        directiveInit: this.directiveInit,
        eventBroker: this.eventBroker
      };
      var availArgs = ['bounds', 'onstart', 'oncomplete', 'shiftKey', 'onmove', 'grid', 'vertical', 'horizontal', 'disabled', 'events-only'];
      availArgs.filter(function (a) {
        return vm[a] !== undefined;
      }).forEach(function (prop) {
        return moveArgs[prop] = vm[prop];
      });

      if (this.target) {
        if (this.target === 'parent') {
          moveArgs.target = vm.$el.parentElement;
        } else {
          moveArgs.target = vm.$parent.$refs[this.target];
        }
      }

      this.moveArgs = moveArgs;
    },
    eventBroker: function eventBroker(_ref) {
      var name = _ref.name,
          args = _ref.args;
      this.$emit(name, args);
    },
    directiveInit: function directiveInit(rpcFn) {
      this.rpcFunc = rpcFn;
    },
    reposition: function reposition(pos) {
      if (_typeof(pos) === 'object') {
        //console.log({pos});
        if (this.moveArgs.target && !this['events-only']) {
          this.moveArgs.target.style.left = pos.left + 'px';
          this.moveArgs.target.style.top = pos.top + 'px';
          return;
        }

        this.top = pos.top;
        this.left = pos.left;
      } else {
        this.isMoving = pos;
      }
    },
    parentPos: function parentPos(k, v) {
      var vm = this;

      if (vm.isMoving) {
        return;
      }

      Vue.nextTick().then(function () {
        vm[k] = Number(v);
      });
    }
  },
  props: ['tagName', 'target', 'bounds', 'onstart', 'oncomplete', 'onmove', 'posTop', 'posLeft', 'events-only', 'grid', 'vertical', 'horizontal', 'disabled', 'shiftKey'],
  mounted: function mounted(mnt) {
    this.init();
  },
  watch: {
    posTop: function posTop(pt) {
      this.parentPos('top', pt);
    },
    disabled: function disabled(disable) {
      this.moveArgs.disabled = true;
      this.rpcFunc({
        disable: true
      });
    },
    posLeft: function posLeft(pl) {
      this.parentPos('left', pl);
    }
  }
};

/* script */
var __vue_script__ = script;
/* template */

var __vue_render__ = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c(_vm.tag, {
    directives: [{
      name: "movable",
      rawName: "v-movable",
      value: _vm.moveArgs,
      expression: "moveArgs"
    }],
    tag: "component",
    staticClass: "--movable-base",
    style: _vm.position,
    attrs: {
      "move-disabled": _vm.disabled
    }
  }, [_vm._t("default")], 2);
};

var __vue_staticRenderFns__ = [];
/* style */

var __vue_inject_styles__ = function __vue_inject_styles__(inject) {
  if (!inject) return;
  inject("data-v-1a80d1f0_0", {
    source: ".--movable-base[data-v-1a80d1f0]{position:absolute;cursor:pointer}",
    map: undefined,
    media: undefined
  });
};
/* scoped */


var __vue_scope_id__ = "data-v-1a80d1f0";
/* module identifier */

var __vue_module_identifier__ = undefined;
/* functional template */

var __vue_is_functional_template__ = false;
/* style inject SSR */

/* style inject shadow dom */

var __vue_component__ = /*#__PURE__*/__vue_normalize__({
  render: __vue_render__,
  staticRenderFns: __vue_staticRenderFns__
}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, __vue_create_injector__, undefined, undefined);

var index = {
  install: function install(Vue) {
    Vue.component("movable", __vue_component__);
  }
};

module.exports = index;
